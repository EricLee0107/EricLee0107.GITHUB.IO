---
title: leetcode-7-ReverseInteger
copyright: true
toc: true
date: 2019-05-25 22:57:21
tags: leetcode
---
#### 题目摘要
给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

注意:
假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

<!--more-->

#### 思路
1. 有范围限制，所以需要做范围判定。
2. 首先是将要被反转的数，通过对10取余数可以得到当前的最末尾，通过对10取整可以得到反转一位后剩余的数

一些变量的意义
pop:未被反转的数的最后一位（初始值0）
x:未被反转的数
rev:反转后的数(初始值0)

所以

`pop` = `x`%`10`;

`x` = `x`/ `10`;

`rev` = `rev`*`10` + `pop`


如果最新反转后的数超出限定范围则返回0。

是否在限定范围内的判定：

2^31 = 2147482648;

所以
最大值为 2147482647;
最小值为 -2147482648;

但我们不能在
`rev` = `rev`*`10` + `pop`计算之后才进行比较，因为计算后没法判断是越界后的值还是正常值，
所以，要在计算前判断 `rev` 是否大于等于`INT_MAX`/10 ，如果大于则计算后一定越界，如果等于则需要看`pop`是否大于7（INT_MAX最大值的最后一位为7），如果rev为负值就要判断是否小于等于`INT_MIN`/10，如果小于则必定越界，如果等于则判断`pop`是否小于-8，如果小于-8 则越界，否则为范围内值。

#### 代码
```c++
int reverse(int x)
{
	int pop = 0;
	int rev = 0;
	while (x != 0)
	{
		pop = x % 10;
		x /= 10;
		if (rev > INT_MAX / 10 || (rev == INT_MAX / 10 && pop > 7)) return 0;
		if (rev < INT_MIN / 10 || (rev == INT_MIN / 10 && pop < -8)) return 0;
		rev = rev * 10 + pop;
	}
	return rev;
}
```



