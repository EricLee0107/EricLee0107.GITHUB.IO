---
title: LeetCode13-RomanToInteger
author: 李志伟
tags: [leetcode]
copyright: true
categories:
  - LeetCode
toc: true
date: 2019-05-27 21:14:41
---
#### 题目摘要

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
``` 
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

- I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
- X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
- C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

<!--more-->
#### 思路
1. 因为每一个罗马数字代表一个值，所以需要一个map表保存每个罗马数字代表的值。
2. 从头遍历字符串s的每一个字符 ，根据每一个罗马字符的值计算最终值。 遍历的过程中有两种字符组合的情况，一种是普通情况（只有自己一个字符即代表一个数字值）；第二种是特殊情况（也就是题目中给出的六种组合）

关于特殊情况，根据题目可以知道前一个字符都小于后一个字符才会构成减法，比如`IV`,`I`<`V` 即此时两个字符代表的意思即`V-I`,代码`mp[s[i]] < mp[s[i+1]`
因此我们可以再循环的时候判断当前字符值和是否小于后面的字符值，如果小于则两个字符需要一起计算，且两个字符代表的值为`后一个字符值` - `前一个字符值`
代码`num+= (mp[s[i+1]]-mp[s[i]])`
最终的结果就是 每个字符组合（单个或特殊）的累加


#### 代码

```c++
int romanToInt(string s) {
        map<char,int> mp;
        mp['I'] = 1;
        mp['V'] = 5;
        mp['X'] = 10;
        mp['L'] = 50;
        mp['C'] = 100;
        mp['D'] = 500;
        mp['M'] = 1000;
        int s_size = s.size();
        int num = 0;
        int i=0;
        while(i<s_size-1)
        {
            if (mp[s[i]] < mp[s[i+1]])
            {
                num+= (mp[s[i+1]]-mp[s[i]]);
                i=i+2;
            }
            else
            {
                num += mp[s[i]];
                i++;
            }
                
        }
        num += mp[s[i]];
        return num;
    }
```
